
1：为什么需要第三次握手
	防止已失效的请求报文段突然又传送到了服务端而产生连接的误判

客户端发送了一个连接请求报文段A到服务端，但是在某些网络节点上长时间滞留了，而后客户端又超时重发了一个连接请求报文段B
该服务端，而后正常建立连接，数据传输完毕，并释放了连接。但是请求报文段A延迟了一段时间后，又到了服务端，这本是一个
早已失效的报文段，但是服务端收到后会误以为客户端又发出了一次连接请求，于是向客户端发出确认报文段，并同意建立连接。
那么问题来了，假如这里没有三次握手，这时服务端只要发送了确认，新的连接就建立了，但由于客户端没有发出建立连接的请求，
因此不会理会服务端的确认，也不会向服务端发送数据，而服务端却认为新的连接已经建立了，并在 一直等待客户端发送数据，
这样服务端就会一直等待下去，直到超出保活计数器的设定值，而将客户端判定为出了问题，才会关闭这个连接。
这样就浪费了很多服务 器的资源。而如果采用三次握手，客户端就会向服务端发出确认，服务端由于收不到确认，就知道客户端没有
要求建立连接，从而不建立该连接

2： MSL(maximum segment lifetime)：最大报文生命周期
	MSL是任何IP数据报(TTL)能够在因特网存活的最长时间，时间是有限的，因为每个数据报都含有一个限跳（hop limit）的8位字段
	它的最大值是255（简单的讲就是不同经过超过255个路由器）,尽管这个跳数限制而不是真正的时间限制，我们仍然假设
	最大限跳的分组在网络中存在的时间不可能超过MSL秒，MSL的具体值通常为30秒或者是2分钟


3：TIME_WAIT状态
	TCP在关闭的时候有个四次挥手的过程，主动关闭方在四次挥手的最后一个ACK发送之后会变成TIME_WAIT状态，这个状态维持2MSL

 	从TIME_WAIT状态到CLOSED状态有一个超时设置，这个超时设置是2MSL(端口占用时间)
 
	
4：为什么存在TIME_WAIT状态（时间等待状态）

	1：可靠的实现TCP全双工连接终止
		由于网络的问题，可能最后一次ack报文不一定被服务器收到，此时服务器会重新发送FIN报文，所以TIME_WAIT状态是
		用来重新发送可能丢失的ack报文		
		
	2：保证让迟来的TCP报文段有足够的时间被识别丢弃
	 如果不存在TIME_WAIT 状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接，端口可能还被占用，新的连接可能接受
	 到原来连接携带的报文，存在TIME_WAIT,我们将无法立即使用该链接占用着的端口来建立一个连接



5：四次挥手状态
	ESTABLISHED建立状态-->FIN-WAIT-1（终止等待1）状态---->服务端CLOSE-WAIT（关闭等待）状态--->FIN-WAIT-2（终止等待2）
	--->LAST-ACK（最后确认）状态--->TIME-WAIT（时间等待）状态--->CLOSED状态
   三次握手状态
	SYN-SENT(同步已发送)--->SYn-RCVD(同步已收到)--->ESTABLISHED（连接状态）



6：FLAG标志位
	笔记

7：TTL（time-to-live）生存时间字段

        在IP首部中的8位字段,设置了数据报可以经过的最多路由器数，制定了数据报的生存时间

   RTT（round-trip-time）往返时间

       TCP超时与重传中最重要的部分就是对一个给定连接的往返时间RTT的测量


8：输入url经历了哪些过程
	DNS域名解析，三次握手，HTTP请求，HTTP响应，四次挥手，渲染页面












